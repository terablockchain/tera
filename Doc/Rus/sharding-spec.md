

## Схема обмена сообщениями

Смарт-контракты могут обмениваться сообщениями между друг другом, в том числе между разными шардами. 

При создании смарт-контракта задается высота в блоках, которая определяется финальность передачи сообщения из одного щарда в другой. При достижении такого значения сообщение передается на дальнейшую обработку в смарт-контракт. Минимальная высота - это фактическ величина безопасности в случае если смарт-контракт является каналом передачи ценностей или другой важной информации. Чем он больше тем более безопасным является канал, но с другой стороны - больше времени нужно ожидать пользователям для завершения операции. 

Процессом переноса сообщений из одного шарда в другой занимаются те майнеры, которые одновременно майнят эти два шарда. В случае если нет таких майнеров, то сообщение будет отложено и ждать их появления.





## Безопасность

Безопасность каналов можно определить через стоимость атаки 51% на время которое необходимо для успешной передачи сообщения в шард приемник. Чем быстрее канал, тем дешевле атака или другими словами больше риск. Управляя рисками мы можем построить схему, которая обеспечивает одновременно высокую безопасность и высокую производительность. Для этого создадим два канала передачи ценностей:



1. Основной канал - медленный, но надежный канал. Время фиксации всегда указывается достаточно большое, например 1 млн блоков. Этот канал имеет свой токен в шарде приемнике, который и отождествляет монету шарда источника.
2. Быстрый канал используется для быстрой передачи небольшого размера ценностей (по сравнению со стоимостью атаки). Например, фиксация операции через 100 блоков. Канал тоже имеет свой токен,который будем называть **транзитным**, он нужен только для кратковременного использования.




Схема работы такова:



1. Пользователь отправляет сумму ценностей через быстрый канал (сумма ценностей всегда меньше стоимости атаки)
2. Получив их в шарде приемнике в виде транзитных токенов он их меняет на основные токены через встроенный DEX. Основные токены передаются через медленный канал, поэтому безопасны.
3. Обеспечением ликвидности транзитных токенов занимается арбитражник. Он занимается передачей транзитных токенов назад в шард источник, а основных токенов в шард приемник. Чтобы мотивировать его выставлять ордера на DEX курс будет не 1 к 1, а с определенной наценкой в которую закладывается стоимость заморозки капитала и его прибыль. Конкретный курс будет регулировать рынок.

 


## Отправка монет из кошелька между шардами

Есть возможность отправки монет напрямую из интерфейса кошелька между счетами соседних шардов, для это адрес счета получателя должен содержать название шарда и номера счета, разделенные двоеточием: “SHARD:AccNumber”

При этом название шарда резолвится в номер аккаунта со смарт-контрактом, который является шлюзом (как вариант этот список соответствий можно зашивать в сам интерфейс кошелька).

Причина по которой используется промежуточный смарт-контракт - это изолирование ответственности. В случае компрометации одного шарда ценности других шардов не пострадают. При кросс-переводах монеты остаются на счете смарт-контракта внутри блокчейна, в другой блокчейн попадает только своеобразная расписка, на основании которой делаются движения токенов.

Такая модель позволяет создавать шарды очень широкого назначения, например временные но с высокой производительностью внутри. 

Пример: Создается шард1, продаются токены на него, пользователи начинают работать с даппами внутри него совершая 1000 tps, через некоторое время когда размер базы превышает разумный предел, например 1000 Гбайт, создается Шард2, токены меняются на токены шарда 1, все переходят работать в шард2, майнеры отключают поддержку 1-го шарда.


## Новые методы в смарт-контрактах

Новый встроенный метод для передачи сообщений (вызывается в шарде источнике):


```
SendMessage(ShardPath,Confirms,Method,Params,ParamsArr)
```


где: 


```
    ShardPath - строка в формате ИмяШарда:НомерСчета
    Confirms - число подтверждений, которое должно совпадать с числом указанным при создании канала обмена в шарде приемнике
    Method - имя метода, который будет вызван для обработки данного сообщения, этот метод должен быть помечен признаком message
    Params - параметры, которые передаются в указанный метод
    ParamsArr - параметры в виде массива байт, которые передаются в указанный метод
```

пример:



```js
//shard1 FLEX
function DoSend(Gate,To,Sum,Desc)
{
   if(context.ToNum!==100234)
       throw "Error paychannel account";

   //we send a command to move the token to another shard
   SendMessage("DEV:200195",5,"SendCoins",{To:To,Sum:Sum,Desc:Desc});
}
```



```js
//shard2 DEV
"message"
function SendCoins(Params,ParamsArr)
{
   //checking the correct call - from the correct shard and the correct smart contract
   if (context.Tx.ShardFrom!=="FLEX")
       throw "Error cross-shard name";

   if (context.Tx.AccountFrom!==100234)
       throw "Error paychannel gate";

   if (context.Tx.Confirms!==5)
       throw "Error confirms";

   //sending a token
   Send(Params.To, Params.Sum,Params.Desc);

}
```



## Спецификация транзакций для кросс-шардинговых сообщений

Если у нас есть нода, которая майнит несколько шардов одновременно, то при создании блока она может добавить в него специальные транзакции, которые содержат информацию о наличии в других шардах сообщений, предназначенных для нашего блокчейна. Такие транзакции сами по себе не участвуют в обмене между нодами до создания блока. Они могут передаваться другим нодам только неотрывно от блока.

Майнеры выполняют голосование за тот или иной состав сообщений в блоках путем создания виртуальных цепочек через специальные транзакции голосования, чем больше блоков содержит цепочка, тем больше достоверность сообщения. При достижении определенного порога, задаваемого изначально, происходит фиксация сообщения в шарде получателе. Фактически майнеры выполняют роль оракулов - свидетелей наличия какой-либо информации в шарде источнике.


Эта механика осуществляется одним методом в шард 1 и одним видом транзакции в шарде 2:

```
Шард 1
```



### SendMessage

Встроенный метод, вызываемый из кода смарт-контракта, например при получении денег на счет, являющийся каналом передачи ценностей в другой шард. Сообщения можно передавать только на базовый счет (**Base Account) **смарт-контракта.

_Действия:_

<span style="text-decoration:underline;">Все ноды (при обработке)</span>: Запись в таблицу исходящих сообщений **CrossOut**

<span style="text-decoration:underline;">Майнер</span>: Передача по приватным каналам связи в другой шард актуальное состояние таблицы **CrossOut **шарда 1 в таблицу **CrossIn **шарда 2


```
Шард 1 и 2
```



### NEW-SHARD

Регистрация нового шарда для обмена с данным блокчейном

<span style="text-decoration:underline;">Формат:</span>


```
    Type: "byte",
    ShardName: "str8",
    Description: "str40",
    Confirms: "uint32"
```


_Действия:_

<span style="text-decoration:underline;">Пользователь-инициатор</span>: Отправка транзакции с уникальным именем шарда с которым создается канал обмена, она обязательно должна быть платной, чтобы защититься от DDOS.

<span style="text-decoration:underline;">Все ноды (при обработке)</span>: Занесение нового имени в список каналов.

<span style="text-decoration:underline;">Пример:</span>


```
{
  "Type": 111,
  "Version": 4,
  "OperationID": 392,
  "FromID": 34,
  "To": [
    {
      "PubKey": [],
      "ID": 0,
      "SumCOIN": 10000,
      "SumCENT": 0
    }
  ],
  "Description": "Shard DEV:5",
  "DeprecatedOperationID": 0,
  "Body": {
    "Type": 60,
    "ShardName": "DEV",
    "Description": "Develop chain v 1",
    "Confirms": 5,
    "Reserve": "000000000000"
  },
  "Sign": "C1940641953FDF90AAE9FD3F31E3A75DD39BAEC53453BAFD2BE4DA3F9C3EE76903FAD042ADE7DFB68CD3A948F7BA275852F3331A0A49FF5A102D8AB31292B6F2"
}
```


В примере выше транзакция создания шарда (выделена жирным) завернута в транзакцию оплаты. 


```
Шард 2
```



### VBLOCK

Виртуальные блоки со списком сообщений из шарда источника.

Майнеры строят виртуальные цепочки блоков и тем самым голосуют за состав сообщений. В случае если блок предыдущего майнера не имеет ошибок, от него создается новый блок, в случае если блок содержит хоть одну ошибку - он откидывается, а в качестве предыдущего блока берется последний правильный. 

Эта схема идентична голосованию по схеме За или Против в котором вес голосов равен друг другу. При такой схеме атака возможно только при наличии 51% злонамеренных майнеров в течении времени пока идет голосование. Период голосования длится до тех пор пока разница высот цепочки лидера и орфана не достигнет заранее задаваемого значения (например 100 блоков для быстрого канала и 1 млн блоков для медленного, но очень надежного канала)

При достижении требуемой высоты блоков майнер устанавливает признак **<code>StartRun:1 </code></strong>для запуска обработки кросс-шардинговых сообщений, т.е. запускается метод смарт-контракта, который был задан в транзакции CROSS-TX (в методе можно получить к ней доступ через конструкцию <em>context.Tx</em>)

<span style="text-decoration:underline;">Формат:</span>


```
    Type:"byte",
    ShardName: SHARD_STR_TYPE,
    Confirms:"uint32",
    PrevRowHash:"hash",
    PrevRowNum:"uint",
    CrossTx:
       [{
           Msg:CROSS_MSG_VBLOCK
       }],
    StartRun:"byte"
```


<span style="text-decoration:underline;">Пример:</span>


```
{
  "Type": 201,
  "ShardName": "DEV",
  "Confirms": 5,
  "PrevRowHash": "E389C888C2BFE1B1AD67B99B338033C00F72955E86D93D497DD9270ED06C2CD7",
  "PrevRowNum": 6,
  "CrossTx": [
    {
      "Msg": {
        "BlockNumFrom": 2592,
        "TxNumFrom": 0,
        "AccountFrom": 12,
        "Iteration": 1,
        "Mode": 1,
        "AccountTo": 12,
        "MethodName": "SendCoins",
        "Params": "{"To":"190","Sum":200,"Desc":"hi"}",
        "ParamsArr": [],
        "Confirms": 5,
        "Reserve": "000000000000"
      }
    }
  ],
  "StartRun": 1,
  "Reserve": "00000000"
}
```


_Действия:_

<span style="text-decoration:underline;">Майнер</span>: 

-Добавление новой транзакции в блок, если ее еще не было в предыдущих корректных блоках (сравнение таблиц **CrossIn **и **CrossRun ** + необработанные блоки).

-Указание последнего правильного блока цепочки. 

<span style="text-decoration:underline;">Майнер (при обработке)</span>: Добавление в приватную базу ссылки на последний правильный блок

<span style="text-decoration:underline;">Все ноды (при обработке)</span>: 

-Запись в таблицу **CrossRun**

-Определение условий запуска (есть требуемая высота блоков, еще не было запуска), запуск смарт-контракта, установка признака.


### Синхронизация списков транзакций

Нам нужно достичь одинакового состояния списка кросс-транзакций между нодой источником и нодой приемником. Верхние строки в таких списках постоянно модифицируются из-за свойства блокчейна часто переписывать цепочки блоков при поиске лидера.

Предлагается такое решение: список содержит поля SNum и SHash в которые раздельно для каждого шарда записывается номер по порядку и связанный с предыдущей строкой хэш: 

_Hash=sha3(PrevHash,RowData)_

Таким образом пара SNum + SHash может являться своеобразным курсором - итератором для быстрой синхронизации двух списков в асинхронном режиме.




Логика:



1. На стороне-приемнике **Dest **берем из списка последнее значение SNum + SHash и используя его как итератор передаем его сторону-источник **Src**
2. На стороне **Src ** сравниваем значение хэша в строке с номером SNum 
    1. Если он совпадает, то возвращаем “result:1” и массив Arr со строками, начиная со строки с SNum + 1 (т.е. которых нет в списке Dst)
    2. Если не совпадает, то возвращаем “result:0”
3. Сторона **Dest**:
    3. При положительном результате загружаем новые данные
    4. При нулевом - уменьшаем номер итератора на величину Delta. При повторных нулевых результатах Delta увеличиваем на 10%, но при условии что ее значение не превышает 1/20 остатка SNum (для предотвращения гигантских шагов назад).


## Создание шардинга

Каждый шард это отдельный блокчейн. Ноды из разных шардов работают в своем адресном пространстве и их объекта такие как счета пользователей, смарт-контракты, блоки и прочие не пересекаться, для того чтобы обеспечить пересылку сообщений между разными шардами нужно выполнить две вещи:



1. Зарегистрировать в каждом шарде имя другого шарда
2. Майнеру запустить ноды в разных шардах, объединив их в один доверенный кластер через установку одинакового значения константы COMMON_KEY (оно должно содержать уникальное секретное слово для каждого майнера).

Таким образом у одного майнера ноды из разных шардов, имеющие одинаковое значение константы COMMON_KEY  будут состыковываться с друг другом и обмениваться между собой кросс-шардинговыми транзакциями.

Когда вы скачиваете исходные коды Тера, то обычно они располагаются в каталоге _wallet/Source_ на своем компьютере. В тоже время данные, такие как база данных блокчейна, константы и другие настройки создаются сохраняются в каталогу _wallet/DATA_. Общий вид папок таков: \
**_DATA_** \
**_Source_** \
 \
В мире блокчейна принято что код - это закон, поэтому нужно место куда класть код, но так чтобы он не был перезаписан при обновлении. Поэтому в Тера уникальные настройки шарда, включая измененные коды помещаются в файл _DATA/shard.js_

 \
Таким образом, если в каталоге DATA есть файл shard.js, то при стандартной команде запуска: _node run-node.js_ фактически запускается шард. \
 \
Вот пример файла настроек создания своего шарда [http://212.80.217.191/shard.js](http://212.80.217.191/shard.js), который в можете взять их за основу при создании своего шарда:


```js
//shard FLEX
'use strict';

global.NETWORK="TEST-JINN";
global.SHARD_NAME="FLEX";
global.START_NETWORK_DATE=1605383500000;
global.CONSENSUS_PERIOD_TIME=3000;//ms



global.START_HISTORY=1;
global.TEST_MINING=1;
global.START_MINING=10;
//global.BLOCK_CREATE_INTERVAL=1;


DevKeysInit();

//начальные ip нод
SHARD_PARAMS.SeedServerArr=[{ip: "212.80.217.191", port: 30000, Score:10000000,System:1}];




SHARD_PARAMS.GenesisAccountCreate=function()
{
    ACCOUNTS.DBStateWriteInner({Num:0,PubKey:[],Value:{BlockNum:1,SumCOIN:1*TOTAL_SUPPLY_TERA},Name:"System"},1);
    ACCOUNTS.DBStateWriteInner({Num:1,PubKey:Buffer.from("026A04AB98D9E4774AD806E302DDDEB63BEA16B5CB5F223EE77478E861BB583EB3","hex"),Value:{BlockNum:1,SumCOIN:0},Name:"Development"},1);
};


SHARD_PARAMS.GenesisSmartCreate=function()
{
    SMARTS.DBSmartWrite({Num:0,ShortName:SHARD_NAME,Name:SHARD_NAME,Description:SHARD_NAME,BlockNum:0,TokenGenerate:1,Account:0,Category1:0});
};


SHARD_PARAMS.DoCoinBaseTR=function(Block)
{
    if(Block.BlockNum<global.START_MINING)
        return;

    var OperationNum=0;
    OperationNum++;
    ACCOUNTS.SendMoneyTR(Block, 0, 1, {SumCOIN:1,SumCENT:0}, Block.BlockNum, 0xFFFF, "", "Development", 1, 0, OperationNum);

    var MinerID=ACCOUNTS.GetMinerFromBlock(Block);
    if(MinerID)
    {
        OperationNum++;
        ACCOUNTS.SendMoneyTR(Block, 0, MinerID, {SumCOIN:3,SumCENT:0}, Block.BlockNum, 0xFFFF, "", "Coin base", 1, 0, OperationNum);
    }
};

global.PRICE_DAO=function (BlockNum)
{
    return {NewAccount:1, NewSmart:10, NewTokenSmart:100, NewShard:1000};
}


function DevKeysInit()
{
    //for genesis block create
    var PubKey=Buffer.from("026A04AB98D9E4774AD806E302DDDEB63BEA16B5CB5F223EE77478E861BB583EB3","hex");

    //for accounts(8-15) create
    global.ARR_PUB_KEY=[];
    for(var i=0;i<100;i++)
        global.ARR_PUB_KEY[i]=GetHexFromArr(PubKey);

    //for check code sign in autoupdate mode
    global.DEVELOP_PUB_KEY_ARR=[Buffer.from("022E80AA78BC07C72781FAC12488096F0BFA7B4F48FBAB0F2A92E208D1EE3654DF","hex")];

}
```


Чтобы запустить другие ноды вашего шарда необходимо разместить этот файл в папке DATA на этих нодах. Это можно сделать путем копирования файлов вручную или указав адрес с уже запущенным шардом в  параметре **_from_**, пример: \
_node set from:[212.80.217.191](http://212.80.217.191/shard.js)_
